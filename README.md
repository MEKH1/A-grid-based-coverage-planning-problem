# A-grid-based-coverage-planning-problem

# Assignment 1.0.A

# Table of Contents
1. [Problem Overview](#problem_overview)
2. [How to run the code](#run_code)
3. [Functions](#Functions)
4. [Main Challenge](#Evaluation)


## 

Problem Overview/
## Problem Over to run the code <a name="run_code"></a>

This project solves a grid-based coverage planning problem inspired by the classical AI Wumpus World environment. The objective is to control an autonomous agent that must traverse a grid-structured cave and visit every reachable free cell.

### The project focuses on two main computational tasks:

- Plan Verification
    Determine whether a given sequence of movements allows the agent to visit all reachable locations.

- Plan Generation
    Automatically generate a sequence of movements that guarantees full coverage of the environment.

### Environment Model

- The environment is represented as a rectangular grid where each cell belongs to one of three categories:

    - Wall (X) — blocked cell that cannot be entered.

    - Empty cell ( ) — accessible cell that must be visited.

    - Starting position (S) — optional initial location of the agent.

- The grid behaves as a toroidal environment:

    - If the agent moves beyond one edge of the grid, it reappears on the opposite side.

    - If the agent attempts to move into a wall, it remains in its current position.

    - This behaviour increases the complexity of coverage planning.


## Main Challenge <a name="Main Challenge"></a>

- Depth-First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking, which means it delves deep into a graph following one path until it reaches a dead end, then retreats to explore other branches. While DFS can find a path between two points, it might not always be direct, particularly in complex graphs with indirect routes. This is because DFS focuses on depth and doesn't necessarily connect the endpoints of different paths directly. 
- To address this limitation, one effective solution is to use Breadth-First Search (BFS) to find the shortest path between the endpoint of one DFS path and the starting point of another, thereby filling in any gaps and ensuring a more coherent and efficient overall path.


## How to run the code <a name="run_code"></a>
- In this repository you will find two main python files

******`**wumpus.py`**** ******`**methods.py`****

- modifiy the directory variable in `wumpus.py` to suit your working space

- also modify the saving directory in each method in `methods.py`to suit your working space

- then simply run `python wumpus.py`

  

###  `wumpus.py`

- This is used to read all text files

- Depends on the first line in the txt file it will call either ******`**Check_plan`**** function or ******`**Find_plan`****

- and send to these function the ****cave map**** and the ****path**** if it is exist


###  `methods.py`

****contains multple functions****

- `Check_Plan(cave, path,filename)`

    - this function solve the check plan problems with starting point

    - and check if the starting point is exit if not it will call **`Check_Plan_without_starting_point`**


- `Check_Plan_without_starting_point(cave,path,filename)`


    -  this will return if it is good plan

    

    - and if it is bad plan will all non visited spots from different starting point

    

    > all_visited.append(set(visited))

    

    > #Find intersection of all visited sets

    

    > visited_by_all  =  set.intersection(*_all_visited)_

    

    > not_visited_at_all  =  set(empty_space) -  visited_by_all

    

-  `Find_Plan(cave,filename).`

    

    - this function solve the Find plan problems with starting point


    - it will create a grahp using `get_neighbors` it will find the neighbors for all empty spots and considering the starting point also if it is exist


    - then dfs algorithim will be applied by calling `dfs(visited, graph, node)`method

    

    - then it will check the path generated by dfs if it has jumps by calliing `check_for_jump(graph,dfs_path,empty_nodes,cave)` method if jump is found it will call `bfs_shortest_path(graph, start, goal)` to fill the gaps in the path

    -  if the starting point is exit if not it will call **`Find_Plan_without_S`**

  

-  `Find_Plan_without_S(cave,filename).`

    

    -  this function will take all possible starting point from all empty nodes then it will generate paths for all starting point and save them in a dictionary then it will call `Check_Plan_The_founded_PLAN(cave,empty_space, All_pathes)` method.

  

-  `Check_Plan_The_founded_PLAN(cave,empty_space, All_pathes).`

  

    - the main task of this method is to create a path suitable for all starting in order to avoid miss spots regardless the starting point.

    

-  `path_to_directions(path,cave).`

    

    - at the end of each method this fuction will be called to translate the path to directions **SNWE**

  

  

## Functions <a name="Functions"></a>
  

### 1. `Check_Plan`

- ****Purpose****: Evaluates if a given path (`path`) effectively covers all the empty spaces in a `cave` (grid).

- ****Parameters****:

    - `cave`: A 2D list representing the grid, with elements as a wall ('X'), empty space (' '), or starting position ('S').

    - `path`: A string of directions (N, S, E, W).

- ****Functionality****: Checks each movement's validity, handles boundary conditions (like wrapping around edges), and writes the result ('GOOD PLAN' or 'BAD PLAN') to a file.

  

  

### 2. `Check_Plan_without_starting_point`

- ****Purpose****: Similar to `Check_Plan`, but used when there's no defined starting point in the cave.

- ****Functionality****: Tries each empty cell as a potential starting point and determines if any path covers all empty spaces.

  

  

### 3. `Find_Plan`

- ****Purpose****: Generates a cleaning path for the cave when a starting point ('S') is present.

- ****Functionality****: Constructs a graph of the cave, performs a depth-first search (DFS) to visit all nodes, and converts this path into a set of directions.

  

  

### 4. `Find_Plan_without_S`

- ****Purpose****: Similar to `Find_Plan`, but for when there's no 'S' in the cave.

- ****Functionality****: Tries each empty space as a starting point and looks for a path that covers all nodes. Checks which of these paths, if any, can cover the entire cave.

  

  

### 5. `Check_Plan_The_founded_PLAN`

- ****Purpose****: An auxiliary function for `Find_Plan_without_S`, checking the effectiveness of the found paths.

  

  

### 6. `get_neighbors`

- ****Purpose****: Generates a graph from the cave.

- ****Functionality****: Connects each node (non-wall space) to its immediate neighbors, also considering wrapping around edges.

  

  

### 7. `dfs` (Depth-First Search)

- ****Purpose****: A standard graph traversal algorithm.

- ****Functionality****: Explores as far as possible along each branch before backtracking, used to find a path through the cave.

  

  

### 8. `check_for_jump`

- ****Purpose****: Improves the path found by DFS, we check if the connection between two points are not direct.

- ****Functionality****: If a path between two points is not direct, this method finds the direct path using `bfs_shortest_path` and add this sub path will be added to the dfs.

  

  

### 9. `bfs_shortest_path` (Breadth-First Search Shortest Path)

- ****Purpose****: Finds the shortest path between two points in a graph.

- ****Functionality****: Used to find the direct path between two nodes if we found a jump through `check_for_jump` in our generated path.

  

  

### 10. `path_to_directions`

- ****Purpose****: Converts the path found by search algorithms into a string of directions (N, S, E, W).

- ****Functionality****: Based on the movement between each pair of consecutive nodes, it generates a directional string.


